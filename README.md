# Pong-Game
Link to video:

https://drive.google.com/file/d/1ah3SJVIr8jmeWrGi1IyYGsTXFwvlBICV/view?usp=sharing

In this video, I demonstrate all the features of the pong game that I implemented. For the computer paddle to move, I have a function called “setComputerPaddle” that moves the paddle steadily up and down the screen at the same speed. When the paddle touches a wall (either the top or the bottom of the screen), the paddle will switch direction and move in the opposite direction. When looking at the screen, the computer paddle is on the right side along the y axis whereas the user paddle is on the left side along the y axis. Both the user paddle and the computer paddle have the same width and height. The user paddle moves up when the joystick is moved up (or in the video, to the right) and the user paddle moves down when the joystick is moved down (or in the video, to the left). The paddle will continue to move up if the joystick is held in the up position, and vice versa if the joystick is held in the down position. The function “updateUserPaddle” reads in the ADC value for pin A0 and determines whether the paddle should move up or down, or if the joystick is in the neutral position, the paddle will stay in the same position. This function also checks if the paddle is already at the bounds of the screen; if it is, then the paddle will not continue to move in that direction even if the user is toggling the joystick.

In the Initialization of the game, as well as every time a game is reset, the x velocity (called “vX”) and the y velocity (called “yX”) will be updated to a random value between -5 and 5. Note that no matter what the value is, the random value is never set to 0, as otherwise the ball would not be able to touch the paddles. Then, in the function called “updateBallPosition”, the ball will start to move in the random direction at a random speed that is set by the variables “vX” and “yX”. Note that in the function “updateScoreboardUser” and “updateScoreboardComputer”, every time a game ends, the ball position is reset to the middle of the screen and the new random “vX” and “vY” values are determined. The ball also follows proper game dynamics, so it interacts with other components in the game such as the paddles and the boundaries of the game. In the function “checkOutOfBounds”, if the ball is at the top or bottom of the walls, or if it is touching a paddle, the corresponding velocity changes to the negative value of that velocity (not that the velocity can become negative or positive depending on its initial value) so that the ball will stay on the screen.

There is also a scoreboard on the top of the screen. This is Initialized at the beginning of the game and also updates throughout the entire game. The two numbers in the boxes in the middle indicate the current points that the user and the computer game for this particular round. The function “checkOutOfBounds” checks if the computer or user has missed the ball. If the computer misses the ball, then the function “updateScoreboardUser” will increment the current points that the user has by one and update this on the screen. Furthermore, the green LED will flash to indicate that the user has won this point. Similarly, if the user misses the ball, then the function “updateScoreboardComputer” will increment the current points that the computer has by one and update this on the screen. Furthermore, the red LED will flash to indicate that the computer has won this point.

In these two functions, there is another function called “checkRoundFinish” that checks if either the user or the computer has reached 5 points in this round. If they have, then that means the round has ended and the board will be reset, including the current points, which will be reset to 0 points for both the user and the computer. If the user wins, the number of wins will be incremented by 1 and displayed on the screen that reads “Wins:” on the user side (left side). If the computer wins, the number of wins will be incremented by 1 and displayed on the screen that reads “Wins:” on the computer side (right side). Depending on who wins, the corresponding LED will also light up. Then, the next round will start, and this will be indicated by text on the screen that denotes the current round number. Furthermore, in this function called “checkRoundFinish”, since the game is best of 3 rounds, if the number of wins for the user and computer add up to 3, then a black screen will show up with text indicating who won. Furthermore, an LED will light up - it will be red if the computer won this game or green if the user won.

The buzzer sounds with a clack sound every time the ball hits the horizontal boundary surfaces, if the ball hits the paddle or if the ball hits the paddle. This is done in the “checkOutOfBounds” function.

Link to video (wireless control):

https://drive.google.com/file/d/1guYL0s57D8ZWDD44-EcZPl1KWHlHxF/view?usp=sharin

None of the code from Part B was changed for this section. I chose to use a slider to control the user paddle wirelessly. As shown in the video, if I move the slider to the left, then the user paddle moves up the screen along the y-axis. If I move the slider to the right, then the user paddle moves down the screen along the y-axis. If I keep the slider relatively in the middle, then the user paddle also stays in the middle of the screen along the y-axis.

I used V2 (virtual pin 2) for the slider. Thus, as seen in the arduino IDE code, I use the function BLYNK_WRITE(V2) to get the value from virtual pin 2. The values for V2 are controlled by a slider, as shown in the video. The sensor value is a variable that takes and stores the current value of V2. Then, I use analogWrite to send this particular value that was recorded to A0, which is where I am reading the ADC input to move the user paddle.
